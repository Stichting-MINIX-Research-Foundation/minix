/*	$NetBSD: rumpvnode_if.c,v 1.18 2015/04/20 23:11:27 riastradh Exp $	*/

/*
 * Warning: DO NOT EDIT! This file is automatically generated!
 * (Modifications made here may easily be lost!)
 *
 * Created from the file:
 *	NetBSD: vnode_if.src,v 1.69 2015/04/20 23:08:07 riastradh Exp
 * by the script:
 *	NetBSD: vnode_if.sh,v 1.60 2014/01/13 12:07:55 hannken Exp
 */

/*
 * Copyright (c) 1992, 1993, 1994, 1995
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/cdefs.h>
__KERNEL_RCSID(0, "$NetBSD: rumpvnode_if.c,v 1.18 2015/04/20 23:11:27 riastradh Exp $");

#include <sys/param.h>
#include <sys/mount.h>
#include <sys/buf.h>
#include <sys/vnode.h>
#include <sys/lock.h>
#include <rump/rumpvnode_if.h>
#include "rump_private.h"

int
RUMP_VOP_BWRITE(struct vnode *vp,
    struct buf *bp)
{
	int error;

	rump_schedule();
	error = VOP_BWRITE(vp, bp);
	rump_unschedule();

	return error;
}

int
RUMP_VOP_LOOKUP(struct vnode *dvp,
    struct vnode **vpp,
    struct componentname *cnp)
{
	int error;

	rump_schedule();
	error = VOP_LOOKUP(dvp, vpp, cnp);
	rump_unschedule();

	return error;
}

int
RUMP_VOP_CREATE(struct vnode *dvp,
    struct vnode **vpp,
    struct componentname *cnp,
    struct vattr *vap)
{
	int error;

	rump_schedule();
	error = VOP_CREATE(dvp, vpp, cnp, vap);
	rump_unschedule();

	return error;
}

int
RUMP_VOP_MKNOD(struct vnode *dvp,
    struct vnode **vpp,
    struct componentname *cnp,
    struct vattr *vap)
{
	int error;

	rump_schedule();
	error = VOP_MKNOD(dvp, vpp, cnp, vap);
	rump_unschedule();

	return error;
}

int
RUMP_VOP_OPEN(struct vnode *vp,
    int mode,
    struct kauth_cred *cred)
{
	int error;

	rump_schedule();
	error = VOP_OPEN(vp, mode, cred);
	rump_unschedule();

	return error;
}

int
RUMP_VOP_CLOSE(struct vnode *vp,
    int fflag,
    struct kauth_cred *cred)
{
	int error;

	rump_schedule();
	error = VOP_CLOSE(vp, fflag, cred);
	rump_unschedule();

	return error;
}

int
RUMP_VOP_ACCESS(struct vnode *vp,
    int mode,
    struct kauth_cred *cred)
{
	int error;

	rump_schedule();
	error = VOP_ACCESS(vp, mode, cred);
	rump_unschedule();

	return error;
}

int
RUMP_VOP_GETATTR(struct vnode *vp,
    struct vattr *vap,
    struct kauth_cred *cred)
{
	int error;

	rump_schedule();
	error = VOP_GETATTR(vp, vap, cred);
	rump_unschedule();

	return error;
}

int
RUMP_VOP_SETATTR(struct vnode *vp,
    struct vattr *vap,
    struct kauth_cred *cred)
{
	int error;

	rump_schedule();
	error = VOP_SETATTR(vp, vap, cred);
	rump_unschedule();

	return error;
}

int
RUMP_VOP_READ(struct vnode *vp,
    struct uio *uio,
    int ioflag,
    struct kauth_cred *cred)
{
	int error;

	rump_schedule();
	error = VOP_READ(vp, uio, ioflag, cred);
	rump_unschedule();

	return error;
}

int
RUMP_VOP_WRITE(struct vnode *vp,
    struct uio *uio,
    int ioflag,
    struct kauth_cred *cred)
{
	int error;

	rump_schedule();
	error = VOP_WRITE(vp, uio, ioflag, cred);
	rump_unschedule();

	return error;
}

int
RUMP_VOP_FALLOCATE(struct vnode *vp,
    off_t pos,
    off_t len)
{
	int error;

	rump_schedule();
	error = VOP_FALLOCATE(vp, pos, len);
	rump_unschedule();

	return error;
}

int
RUMP_VOP_FDISCARD(struct vnode *vp,
    off_t pos,
    off_t len)
{
	int error;

	rump_schedule();
	error = VOP_FDISCARD(vp, pos, len);
	rump_unschedule();

	return error;
}

int
RUMP_VOP_IOCTL(struct vnode *vp,
    u_long command,
    void *data,
    int fflag,
    struct kauth_cred *cred)
{
	int error;

	rump_schedule();
	error = VOP_IOCTL(vp, command, data, fflag, cred);
	rump_unschedule();

	return error;
}

int
RUMP_VOP_FCNTL(struct vnode *vp,
    u_int command,
    void *data,
    int fflag,
    struct kauth_cred *cred)
{
	int error;

	rump_schedule();
	error = VOP_FCNTL(vp, command, data, fflag, cred);
	rump_unschedule();

	return error;
}

int
RUMP_VOP_POLL(struct vnode *vp,
    int events)
{
	int error;

	rump_schedule();
	error = VOP_POLL(vp, events);
	rump_unschedule();

	return error;
}

int
RUMP_VOP_KQFILTER(struct vnode *vp,
    struct knote *kn)
{
	int error;

	rump_schedule();
	error = VOP_KQFILTER(vp, kn);
	rump_unschedule();

	return error;
}

int
RUMP_VOP_REVOKE(struct vnode *vp,
    int flags)
{
	int error;

	rump_schedule();
	error = VOP_REVOKE(vp, flags);
	rump_unschedule();

	return error;
}

int
RUMP_VOP_MMAP(struct vnode *vp,
    int prot,
    struct kauth_cred *cred)
{
	int error;

	rump_schedule();
	error = VOP_MMAP(vp, prot, cred);
	rump_unschedule();

	return error;
}

int
RUMP_VOP_FSYNC(struct vnode *vp,
    struct kauth_cred *cred,
    int flags,
    off_t offlo,
    off_t offhi)
{
	int error;

	rump_schedule();
	error = VOP_FSYNC(vp, cred, flags, offlo, offhi);
	rump_unschedule();

	return error;
}

int
RUMP_VOP_SEEK(struct vnode *vp,
    off_t oldoff,
    off_t newoff,
    struct kauth_cred *cred)
{
	int error;

	rump_schedule();
	error = VOP_SEEK(vp, oldoff, newoff, cred);
	rump_unschedule();

	return error;
}

int
RUMP_VOP_REMOVE(struct vnode *dvp,
    struct vnode *vp,
    struct componentname *cnp)
{
	int error;

	rump_schedule();
	error = VOP_REMOVE(dvp, vp, cnp);
	rump_unschedule();

	return error;
}

int
RUMP_VOP_LINK(struct vnode *dvp,
    struct vnode *vp,
    struct componentname *cnp)
{
	int error;

	rump_schedule();
	error = VOP_LINK(dvp, vp, cnp);
	rump_unschedule();

	return error;
}

int
RUMP_VOP_RENAME(struct vnode *fdvp,
    struct vnode *fvp,
    struct componentname *fcnp,
    struct vnode *tdvp,
    struct vnode *tvp,
    struct componentname *tcnp)
{
	int error;

	rump_schedule();
	error = VOP_RENAME(fdvp, fvp, fcnp, tdvp, tvp, tcnp);
	rump_unschedule();

	return error;
}

int
RUMP_VOP_MKDIR(struct vnode *dvp,
    struct vnode **vpp,
    struct componentname *cnp,
    struct vattr *vap)
{
	int error;

	rump_schedule();
	error = VOP_MKDIR(dvp, vpp, cnp, vap);
	rump_unschedule();

	return error;
}

int
RUMP_VOP_RMDIR(struct vnode *dvp,
    struct vnode *vp,
    struct componentname *cnp)
{
	int error;

	rump_schedule();
	error = VOP_RMDIR(dvp, vp, cnp);
	rump_unschedule();

	return error;
}

int
RUMP_VOP_SYMLINK(struct vnode *dvp,
    struct vnode **vpp,
    struct componentname *cnp,
    struct vattr *vap,
    char *target)
{
	int error;

	rump_schedule();
	error = VOP_SYMLINK(dvp, vpp, cnp, vap, target);
	rump_unschedule();

	return error;
}

int
RUMP_VOP_READDIR(struct vnode *vp,
    struct uio *uio,
    struct kauth_cred *cred,
    int *eofflag,
    off_t **cookies,
    int *ncookies)
{
	int error;

	rump_schedule();
	error = VOP_READDIR(vp, uio, cred, eofflag, cookies, ncookies);
	rump_unschedule();

	return error;
}

int
RUMP_VOP_READLINK(struct vnode *vp,
    struct uio *uio,
    struct kauth_cred *cred)
{
	int error;

	rump_schedule();
	error = VOP_READLINK(vp, uio, cred);
	rump_unschedule();

	return error;
}

int
RUMP_VOP_ABORTOP(struct vnode *dvp,
    struct componentname *cnp)
{
	int error;

	rump_schedule();
	error = VOP_ABORTOP(dvp, cnp);
	rump_unschedule();

	return error;
}

int
RUMP_VOP_INACTIVE(struct vnode *vp,
    bool *recycle)
{
	int error;

	rump_schedule();
	error = VOP_INACTIVE(vp, recycle);
	rump_unschedule();

	return error;
}

int
RUMP_VOP_RECLAIM(struct vnode *vp)
{
	int error;

	rump_schedule();
	error = VOP_RECLAIM(vp);
	rump_unschedule();

	return error;
}

int
RUMP_VOP_LOCK(struct vnode *vp,
    int flags)
{
	int error;

	rump_schedule();
	error = VOP_LOCK(vp, flags);
	rump_unschedule();

	return error;
}

int
RUMP_VOP_UNLOCK(struct vnode *vp)
{
	int error;

	rump_schedule();
	error = VOP_UNLOCK(vp);
	rump_unschedule();

	return error;
}

int
RUMP_VOP_BMAP(struct vnode *vp,
    int64_t bn,
    struct vnode **vpp,
    int64_t *bnp,
    int *runp)
{
	int error;

	rump_schedule();
	error = VOP_BMAP(vp, bn, vpp, bnp, runp);
	rump_unschedule();

	return error;
}

int
RUMP_VOP_STRATEGY(struct vnode *vp,
    struct buf *bp)
{
	int error;

	rump_schedule();
	error = VOP_STRATEGY(vp, bp);
	rump_unschedule();

	return error;
}

int
RUMP_VOP_PRINT(struct vnode *vp)
{
	int error;

	rump_schedule();
	error = VOP_PRINT(vp);
	rump_unschedule();

	return error;
}

int
RUMP_VOP_ISLOCKED(struct vnode *vp)
{
	int error;

	rump_schedule();
	error = VOP_ISLOCKED(vp);
	rump_unschedule();

	return error;
}

int
RUMP_VOP_PATHCONF(struct vnode *vp,
    int name,
    register_t *retval)
{
	int error;

	rump_schedule();
	error = VOP_PATHCONF(vp, name, retval);
	rump_unschedule();

	return error;
}

int
RUMP_VOP_ADVLOCK(struct vnode *vp,
    void *id,
    int op,
    struct flock *fl,
    int flags)
{
	int error;

	rump_schedule();
	error = VOP_ADVLOCK(vp, id, op, fl, flags);
	rump_unschedule();

	return error;
}

int
RUMP_VOP_WHITEOUT(struct vnode *dvp,
    struct componentname *cnp,
    int flags)
{
	int error;

	rump_schedule();
	error = VOP_WHITEOUT(dvp, cnp, flags);
	rump_unschedule();

	return error;
}

int
RUMP_VOP_GETPAGES(struct vnode *vp,
    off_t offset,
    struct vm_page **m,
    int *count,
    int centeridx,
    int access_type,
    int advice,
    int flags)
{
	int error;

	rump_schedule();
	error = VOP_GETPAGES(vp, offset, m, count, centeridx, access_type, advice, flags);
	rump_unschedule();

	return error;
}

int
RUMP_VOP_PUTPAGES(struct vnode *vp,
    off_t offlo,
    off_t offhi,
    int flags)
{
	int error;

	rump_schedule();
	error = VOP_PUTPAGES(vp, offlo, offhi, flags);
	rump_unschedule();

	return error;
}

int
RUMP_VOP_CLOSEEXTATTR(struct vnode *vp,
    int commit,
    struct kauth_cred *cred)
{
	int error;

	rump_schedule();
	error = VOP_CLOSEEXTATTR(vp, commit, cred);
	rump_unschedule();

	return error;
}

int
RUMP_VOP_GETEXTATTR(struct vnode *vp,
    int attrnamespace,
    const char *name,
    struct uio *uio,
    size_t *size,
    struct kauth_cred *cred)
{
	int error;

	rump_schedule();
	error = VOP_GETEXTATTR(vp, attrnamespace, name, uio, size, cred);
	rump_unschedule();

	return error;
}

int
RUMP_VOP_LISTEXTATTR(struct vnode *vp,
    int attrnamespace,
    struct uio *uio,
    size_t *size,
    int flag,
    struct kauth_cred *cred)
{
	int error;

	rump_schedule();
	error = VOP_LISTEXTATTR(vp, attrnamespace, uio, size, flag, cred);
	rump_unschedule();

	return error;
}

int
RUMP_VOP_OPENEXTATTR(struct vnode *vp,
    struct kauth_cred *cred)
{
	int error;

	rump_schedule();
	error = VOP_OPENEXTATTR(vp, cred);
	rump_unschedule();

	return error;
}

int
RUMP_VOP_DELETEEXTATTR(struct vnode *vp,
    int attrnamespace,
    const char *name,
    struct kauth_cred *cred)
{
	int error;

	rump_schedule();
	error = VOP_DELETEEXTATTR(vp, attrnamespace, name, cred);
	rump_unschedule();

	return error;
}

int
RUMP_VOP_SETEXTATTR(struct vnode *vp,
    int attrnamespace,
    const char *name,
    struct uio *uio,
    struct kauth_cred *cred)
{
	int error;

	rump_schedule();
	error = VOP_SETEXTATTR(vp, attrnamespace, name, uio, cred);
	rump_unschedule();

	return error;
}
