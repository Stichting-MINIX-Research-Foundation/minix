#!/bin/sh
#
#MINIX 3.2.0 dhclient-script

ENTERHOOKS=/etc/dhclient-enter-hooks
EXITHOOKS=/etc/dhclient-exit-hooks
RESOLV=/etc/resolv.conf
SIGNATURE="# Created by dhclient from"
INTSIG="$SIGNATURE $interface"

make_resolv_conf() {
	if [ ! -z "$new_domain_name_servers" ]; then
		if [ -f $RESOLV ]
		then
			while read line; do
				case $line in
				"$SIGNATURE"*)
					;;
				*)
					mv $RESOLV $RESOLV.save;;
				esac
				break
			done < $RESOLV
		fi
		echo "$INTSIG" > $RESOLV
		if [ ! -z "$new_domain_name" ]
		then
			echo search $new_domain_name >> $RESOLV
		fi
		for nameserver in $new_domain_name_servers; do
			echo nameserver $nameserver
		done >> $RESOLV
	fi
}

restore_resolv_conf() {
	if [ -f $RESOLV.save -a -f $RESOLV ]
	then
		while read line; do
			case $line in
			"$INTSIG"*)
				mv $RESOLV.save $RESOLV;;
			esac
			break
		done < $RESOLV
	fi
}

# Must be used on exit.   Invokes the local dhcp client exit hooks, if any.
exit_with_hooks() {
	exit_status=$1
	if [ -f "$EXITHOOKS" ]; then
		. "$EXITHOOKS"
	fi
	# probably should do something with exit status of the local script
	exit $exit_status
}


add_new_routes() {
	for router in $new_routers; do
		add_route -g $router
	done >/dev/null 2>&1

	set -- $new_static_routes
	while [ $# -gt 1 ]; do
		add_route $1 $2
		shift; shift
	done
}

delete_old_routes() {
	for router in $old_routers; do
		del_route default $router
	done >/dev/null 2>&1

	set -- $old_static_routes
	while [ $# -gt 1 ]; do
		del_route $1 $2
		shift; shift
	done

	route -n flush -inet -llinfo -host
}

# Invoke the local dhcp client enter hooks, if they exist.
if [ -f $ENTERHOOKS ]; then
	exit_status=0
	. $ENTERHOOKS
	# allow the local script to abort processing of this state
	# local script must set exit_status variable to nonzero.
	if [ $exit_status -ne 0 ]; then
		exit $exit_status
	fi
fi

#if [ ! -z "$new_host_name" ]; then
#	echo New Host Name: $new_host_name
#fi
#
#if [ ! -z "$new_nis_domain" ]; then
#	echo New NIS Domain: $new_nis_domain
#fi
#
#if [ ! -z "$new_network_number" ]; then
#	echo New Network Number: $new_network_number
#fi

if [ ! -z "$new_broadcast_address" ]; then
#	echo New Broadcast Address: $new_broadcast_address
	new_broadcast_arg=""
#	new_broadcast_arg="broadcast $new_broadcast_address"
fi

if [ ! -z "$old_broadcast_address" ]; then
	old_broadcast_arg=""
#	old_broadcast_arg="broadcast $old_broadcast_address"
fi

if [ ! -z "$new_subnet_mask" ]; then
	new_netmask_arg="-n $new_subnet_mask"
fi

if [ ! -z "$old_subnet_mask" ]; then
	old_netmask_arg="-n $old_subnet_mask"
fi

if [ ! -z "$alias_subnet_mask" ]; then
	alias_subnet_arg="-n $alias_subnet_mask"
fi

case "$reason" in
MEDIUM)
	test -z "" && exit_with_hooks 0

	#eval "ifconfig -I $interface -h 0.0.0.0 " >/dev/null 2>&1

	sleep 1

	exit_with_hooks 0
	;;

PREINIT)
	interface=/dev/$interface
#	if [ ! -z "$alias_ip_address" ]; then
#		ifconfig -I $interface \
#		    -h $alias_ip_address >/dev/null 2>&1
#		del_route $alias_ip_address 127.0.0.1 > /dev/null 2>&1
#	fi

	ifconfig -I $interface -h 0.0.0.0 -n 0.0.0.0 \

	exit_with_hooks 0
	;;

ARPCHECK|ARPSEND)
	exit_with_hooks 0
	;;

BOUND|RENEW|REBIND|REBOOT)
	interface=/dev/$interface

	if [ ! -z "$new_nis_domain" ]; then
	fi

	if type hostname > /dev/null 2>&1; then
	fi
    
	if [ \( ! -z "$old_ip_address" \) -a \( ! -z "$alias_ip_address" \) -a \
	    \( "x$alias_ip_address" != "x$old_ip_address" \) ]; then
		ifconfig -I $interface
		    -h $alias_ip_address > /dev/null 2>&1
		del_route $alias_ip_address 127.0.0.1 > /dev/null 2>&1
	fi

	if [ \( ! -z "$old_ip_address" \) -a \
	    \( "x$old_ip_address" != "x$new_ip_address" \) ]; then
		eval "ifconfig -I $interface -h $old_ip_address "
		del_route $old_ip_address 127.0.0.1 >/dev/null 2>&1

		delete_old_routes
	fi

	if [ \( -z "$old_ip_address" \) -o \
	    \( "x$old_ip_address" != "x$new_ip_address" \) -o \
	    \( "x$reason" = "xBOUND" \) -o \( "x$reason" = "xREBOOT" \) ]; then
		eval "ifconfig -I $interface -h $new_ip_address \
		    $new_netmask_arg $new_broadcast_arg "
		add_route $new_ip_address 127.0.0.1 >/dev/null 2>&1

		add_new_routes
	fi

	if [ \( ! -z "$alias_ip_address" \) -a \
	    \( "x$new_ip_address" != "x$alias_ip_address" \) ]; then
		ifconfig -I $interface -h $alias_ip_address \
		    $alias_subnet_arg
		add_route $alias_ip_address 127.0.0.1
	fi
	make_resolv_conf
	exit_with_hooks 0
	;;

EXPIRE|FAIL|RELEASE|STOP)
	$interface = /dev/$interface
	if [ ! -z "$old_nis_domain" ]; then
	fi

	if [ ! -z "$alias_ip_address" ]; then
		ifconfig -I $interface -h $alias_ip_address
		del_route $alias_ip_address 127.0.0.1
	fi > /dev/null 2>&1

	if [ ! -z "$old_ip_address" ]; then
		eval "ifconfig -I $interface -h $old_ip_address "
		del_route $old_ip_address 127.0.0.1 >/dev/null 2>&1
		delete_old_routes
	fi

	if [ ! -z "$alias_ip_address" ]; then
		ifconfig -I $interface -h $alias_ip_address \
		    $alias_subnet_arg
		add_route $alias_ip_address 127.0.0.1
	fi

	restore_resolv_conf
	exit_with_hooks 0
	;;

TIMEOUT)
	$interface=/dev/$interface
	if [ ! -z "$alias_ip_address" ]; then
		ifconfig -I $interface -h $alias_ip_address
		del_route $alias_ip_address 127.0.0.1
	fi > /dev/null 2>&1

	if [ ! -z "$new_host_name" ]; then
		if type hostname > /dev/null 2>&1; then
			echo "Unimplemented feature : domainname"
#			hostname $new_host_name
		fi
	fi

	if [ ! -z "$new_nis_domain" ]; then
	fi

	eval "ifconfig -I $interface -h $new_ip_address $new_netmask_arg \
	    $new_broadcast_arg "
	sleep 1

	if [ ! -z "$new_routers" ]; then
		set -- $new_routers
		if ping -n -q -c 1 -w 1 $1; then
			if [ \( ! -z "$alias_ip_address" \) -a \
			    \( "x$new_ip_address" != "x$alias_ip_address" \) ]
			then
				ifconfig -I $interface \
				    -h $alias_ip_address $alias_subnet_arg
				add_route $alias_ip_address 127.0.0.1
			fi

			add_route $new_ip_address 127.0.0.1 >/dev/null 2>&1

			add_new_routes
			make_resolv_conf
			exit_with_hooks 0
		fi
	fi

	eval "ifconfig -I $interface -h $new_ip_address "

	delete_old_routes

	exit_with_hooks 1
	;;
*)
	exit_with_hooks 0
	;;
esac
