.\"	$NetBSD: BIO_s_connect.3,v 1.14 2015/06/12 17:01:13 christos Exp $
.\"
.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "BIO_s_connect 3"
.TH BIO_s_connect 3 "2009-07-19" "1.0.1n" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
BIO_s_connect, BIO_set_conn_hostname, BIO_set_conn_port,
BIO_set_conn_ip, BIO_set_conn_int_port, BIO_get_conn_hostname,
BIO_get_conn_port, BIO_get_conn_ip, BIO_get_conn_int_port,
BIO_set_nbio, BIO_do_connect \- connect BIO
.SH "LIBRARY"
libcrypto, -lcrypto
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/bio.h>
\&
\& BIO_METHOD * BIO_s_connect(void);
\&
\& BIO *BIO_new_connect(char *name);
\&
\& long BIO_set_conn_hostname(BIO *b, char *name);
\& long BIO_set_conn_port(BIO *b, char *port);
\& long BIO_set_conn_ip(BIO *b, char *ip);
\& long BIO_set_conn_int_port(BIO *b, char *port);
\& char *BIO_get_conn_hostname(BIO *b);
\& char *BIO_get_conn_port(BIO *b);
\& char *BIO_get_conn_ip(BIO *b, dummy);
\& long BIO_get_conn_int_port(BIO *b, int port);
\&
\& long BIO_set_nbio(BIO *b, long n);
\&
\& int BIO_do_connect(BIO *b);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fIBIO_s_connect()\fR returns the connect \s-1BIO\s0 method. This is a wrapper
round the platform's \s-1TCP/IP\s0 socket connection routines.
.PP
Using connect BIOs, \s-1TCP/IP\s0 connections can be made and data
transferred using only \s-1BIO\s0 routines. In this way any platform
specific operations are hidden by the \s-1BIO\s0 abstraction.
.PP
Read and write operations on a connect \s-1BIO\s0 will perform I/O
on the underlying connection. If no connection is established
and the port and hostname (see below) is set up properly then
a connection is established first.
.PP
Connect BIOs support \fIBIO_puts()\fR but not \fIBIO_gets()\fR.
.PP
If the close flag is set on a connect \s-1BIO\s0 then any active
connection is shutdown and the socket closed when the \s-1BIO\s0
is freed.
.PP
Calling \fIBIO_reset()\fR on a connect \s-1BIO\s0 will close any active
connection and reset the \s-1BIO\s0 into a state where it can connect
to the same host again.
.PP
\&\fIBIO_get_fd()\fR places the underlying socket in \fBc\fR if it is not \s-1NULL,\s0
it also returns the socket . If \fBc\fR is not \s-1NULL\s0 it should be of
type (int *).
.PP
\&\fIBIO_set_conn_hostname()\fR uses the string \fBname\fR to set the hostname.
The hostname can be an \s-1IP\s0 address. The hostname can also include the
port in the form hostname:port . It is also acceptable to use the
form \*(L"hostname/any/other/path\*(R" or \*(L"hostname:port/any/other/path\*(R".
.PP
\&\fIBIO_set_conn_port()\fR sets the port to \fBport\fR. \fBport\fR can be the
numerical form or a string such as \*(L"http\*(R". A string will be looked
up first using \fIgetservbyname()\fR on the host platform but if that
fails a standard table of port names will be used. Currently the
list is http, telnet, socks, https, ssl, ftp, gopher and wais.
.PP
\&\fIBIO_set_conn_ip()\fR sets the \s-1IP\s0 address to \fBip\fR using binary form,
that is four bytes specifying the \s-1IP\s0 address in big-endian form.
.PP
\&\fIBIO_set_conn_int_port()\fR sets the port using \fBport\fR. \fBport\fR should
be of type (int *).
.PP
\&\fIBIO_get_conn_hostname()\fR returns the hostname of the connect \s-1BIO\s0 or
\&\s-1NULL\s0 if the \s-1BIO\s0 is initialized but no hostname is set.
This return value is an internal pointer which should not be modified.
.PP
\&\fIBIO_get_conn_port()\fR returns the port as a string.
.PP
\&\fIBIO_get_conn_ip()\fR returns the \s-1IP\s0 address in binary form.
.PP
\&\fIBIO_get_conn_int_port()\fR returns the port as an int.
.PP
\&\fIBIO_set_nbio()\fR sets the non blocking I/O flag to \fBn\fR. If \fBn\fR is
zero then blocking I/O is set. If \fBn\fR is 1 then non blocking I/O
is set. Blocking I/O is the default. The call to \fIBIO_set_nbio()\fR
should be made before the connection is established because
non blocking I/O is set during the connect process.
.PP
\&\fIBIO_new_connect()\fR combines \fIBIO_new()\fR and \fIBIO_set_conn_hostname()\fR into
a single call: that is it creates a new connect \s-1BIO\s0 with \fBname\fR.
.PP
\&\fIBIO_do_connect()\fR attempts to connect the supplied \s-1BIO.\s0 It returns 1
if the connection was established successfully. A zero or negative
value is returned if the connection could not be established, the
call \fIBIO_should_retry()\fR should be used for non blocking connect BIOs
to determine if the call should be retried.
.SH "NOTES"
.IX Header "NOTES"
If blocking I/O is set then a non positive return value from any
I/O call is caused by an error condition, although a zero return
will normally mean that the connection was closed.
.PP
If the port name is supplied as part of the host name then this will
override any value set with \fIBIO_set_conn_port()\fR. This may be undesirable
if the application does not wish to allow connection to arbitrary
ports. This can be avoided by checking for the presence of the ':'
character in the passed hostname and either indicating an error or
truncating the string at that point.
.PP
The values returned by \fIBIO_get_conn_hostname()\fR, \fIBIO_get_conn_port()\fR,
\&\fIBIO_get_conn_ip()\fR and \fIBIO_get_conn_int_port()\fR are updated when a
connection attempt is made. Before any connection attempt the values
returned are those set by the application itself.
.PP
Applications do not have to call \fIBIO_do_connect()\fR but may wish to do
so to separate the connection process from other I/O processing.
.PP
If non blocking I/O is set then retries will be requested as appropriate.
.PP
It addition to \fIBIO_should_read()\fR and \fIBIO_should_write()\fR it is also
possible for \fIBIO_should_io_special()\fR to be true during the initial
connection process with the reason \s-1BIO_RR_CONNECT.\s0 If this is returned
then this is an indication that a connection attempt would block,
the application should then take appropriate action to wait until
the underlying socket has connected and retry the call.
.PP
\&\fIBIO_set_conn_hostname()\fR, \fIBIO_set_conn_port()\fR, \fIBIO_set_conn_ip()\fR,
\&\fIBIO_set_conn_int_port()\fR, \fIBIO_get_conn_hostname()\fR, \fIBIO_get_conn_port()\fR,
\&\fIBIO_get_conn_ip()\fR, \fIBIO_get_conn_int_port()\fR, \fIBIO_set_nbio()\fR and
\&\fIBIO_do_connect()\fR are macros.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fIBIO_s_connect()\fR returns the connect \s-1BIO\s0 method.
.PP
\&\fIBIO_get_fd()\fR returns the socket or \-1 if the \s-1BIO\s0 has not
been initialized.
.PP
\&\fIBIO_set_conn_hostname()\fR, \fIBIO_set_conn_port()\fR, \fIBIO_set_conn_ip()\fR and
\&\fIBIO_set_conn_int_port()\fR always return 1.
.PP
\&\fIBIO_get_conn_hostname()\fR returns the connected hostname or \s-1NULL\s0 is
none was set.
.PP
\&\fIBIO_get_conn_port()\fR returns a string representing the connected
port or \s-1NULL\s0 if not set.
.PP
\&\fIBIO_get_conn_ip()\fR returns a pointer to the connected \s-1IP\s0 address in
binary form or all zeros if not set.
.PP
\&\fIBIO_get_conn_int_port()\fR returns the connected port or 0 if none was
set.
.PP
\&\fIBIO_set_nbio()\fR always returns 1.
.PP
\&\fIBIO_do_connect()\fR returns 1 if the connection was successfully
established and 0 or \-1 if the connection failed.
.SH "EXAMPLE"
.IX Header "EXAMPLE"
This is example connects to a webserver on the local host and attempts
to retrieve a page and copy the result to standard output.
.PP
.Vb 10
\& BIO *cbio, *out;
\& int len;
\& char tmpbuf[1024];
\& ERR_load_crypto_strings();
\& cbio = BIO_new_connect("localhost:http");
\& out = BIO_new_fp(stdout, BIO_NOCLOSE);
\& if(BIO_do_connect(cbio) <= 0) {
\&        fprintf(stderr, "Error connecting to server\en");
\&        ERR_print_errors_fp(stderr);
\&        /* whatever ... */
\&        }
\& BIO_puts(cbio, "GET / HTTP/1.0\en\en");
\& for(;;) {
\&        len = BIO_read(cbio, tmpbuf, 1024);
\&        if(len <= 0) break;
\&        BIO_write(out, tmpbuf, len);
\& }
\& BIO_free(cbio);
\& BIO_free(out);
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1TBA\s0
