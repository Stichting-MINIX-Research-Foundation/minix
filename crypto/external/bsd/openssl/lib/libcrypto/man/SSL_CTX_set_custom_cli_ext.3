.\"	$NetBSD: SSL_CTX_set_custom_cli_ext.3,v 1.1 2017/01/27 23:00:48 spz Exp $
.\"
.\" Automatically generated by Pod::Man 4.07 (Pod::Simple 3.32)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SSL_CTX_set_custom_cli_ext 3"
.TH SSL_CTX_set_custom_cli_ext 3 "2016-10-14" "1.0.2k" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
SSL_CTX_add_client_custom_ext, SSL_CTX_add_server_custom_ext \- custom TLS extension handling
.SH "LIBRARY"
libcrypto, -lcrypto
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/ssl.h>
\&
\& int SSL_CTX_add_client_custom_ext(SSL_CTX *ctx, unsigned int ext_type,
\&                                   custom_ext_add_cb add_cb,
\&                                   custom_ext_free_cb free_cb, void *add_arg,
\&                                   custom_ext_parse_cb parse_cb,
\&                                   void *parse_arg);
\&
\& int SSL_CTX_add_server_custom_ext(SSL_CTX *ctx, unsigned int ext_type,
\&                                   custom_ext_add_cb add_cb,
\&                                   custom_ext_free_cb free_cb, void *add_arg,
\&                                   custom_ext_parse_cb parse_cb,
\&                                   void *parse_arg);
\&
\& int SSL_extension_supported(unsigned int ext_type);
\&
\& typedef int (*custom_ext_add_cb)(SSL *s, unsigned int ext_type,
\&                                  const unsigned char **out,
\&                                  size_t *outlen, int *al,
\&                                  void *add_arg);
\&
\& typedef void (*custom_ext_free_cb)(SSL *s, unsigned int ext_type,
\&                                    const unsigned char *out,
\&                                    void *add_arg);
\&
\& typedef int (*custom_ext_parse_cb)(SSL *s, unsigned int ext_type,
\&                                    const unsigned char *in,
\&                                    size_t inlen, int *al,
\&                                    void *parse_arg);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fISSL_CTX_add_client_custom_ext()\fR adds a custom extension for a \s-1TLS\s0 client
with extension type \fBext_type\fR and callbacks \fBadd_cb\fR, \fBfree_cb\fR and
\&\fBparse_cb\fR.
.PP
\&\fISSL_CTX_add_server_custom_ext()\fR adds a custom extension for a \s-1TLS\s0 server
with extension type \fBext_type\fR and callbacks \fBadd_cb\fR, \fBfree_cb\fR and
\&\fBparse_cb\fR.
.PP
In both cases the extension type must not be handled by OpenSSL internally
or an error occurs.
.PP
\&\fISSL_extension_supported()\fR returns 1 if the extension \fBext_type\fR is handled
internally by OpenSSL and 0 otherwise.
.SH "EXTENSION CALLBACKS"
.IX Header "EXTENSION CALLBACKS"
The callback \fBadd_cb\fR is called to send custom extension data to be
included in ClientHello for \s-1TLS\s0 clients or ServerHello for servers. The
\&\fBext_type\fR parameter is set to the extension type which will be added and
\&\fBadd_arg\fR to the value set when the extension handler was added.
.PP
If the application wishes to include the extension \fBext_type\fR it should
set \fB*out\fR to the extension data, set \fB*outlen\fR to the length of the
extension data and return 1.
.PP
If the \fBadd_cb\fR does not wish to include the extension it must return 0.
.PP
If \fBadd_cb\fR returns \-1 a fatal handshake error occurs using the \s-1TLS\s0
alert value specified in \fB*al\fR.
.PP
For clients (but not servers) if \fBadd_cb\fR is set to \s-1NULL\s0 a zero length
extension is added for \fBext_type\fR.
.PP
For clients every registered \fBadd_cb\fR is always called to see if the
application wishes to add an extension to ClientHello.
.PP
For servers every registered \fBadd_cb\fR is called once if and only if the
corresponding extension was received in ClientHello to see if the application
wishes to add the extension to ServerHello. That is, if no corresponding extension
was received in ClientHello then \fBadd_cb\fR will not be called.
.PP
If an extension is added (that is \fBadd_cb\fR returns 1) \fBfree_cb\fR is called
(if it is set) with the value of \fBout\fR set by the add callback. It can be
used to free up any dynamic extension data set by \fBadd_cb\fR. Since \fBout\fR is
constant (to permit use of constant data in \fBadd_cb\fR) applications may need to
cast away const to free the data.
.PP
The callback \fBparse_cb\fR receives data for \s-1TLS\s0 extensions. For \s-1TLS\s0 clients
the extension data will come from ServerHello and for \s-1TLS\s0 servers it will
come from ClientHello.
.PP
The extension data consists of \fBinlen\fR bytes in the buffer \fBin\fR for the
extension \fBextension_type\fR.
.PP
If the \fBparse_cb\fR considers the extension data acceptable it must return
1. If it returns 0 or a negative value a fatal handshake error occurs
using the \s-1TLS\s0 alert value specified in \fB*al\fR.
.PP
The buffer \fBin\fR is a temporary internal buffer which will not be valid after
the callback returns.
.SH "NOTES"
.IX Header "NOTES"
The \fBadd_arg\fR and \fBparse_arg\fR parameters can be set to arbitrary values
which will be passed to the corresponding callbacks. They can, for example,
be used to store the extension data received in a convenient structure or
pass the extension data to be added or freed when adding extensions.
.PP
The \fBext_type\fR parameter corresponds to the \fBextension_type\fR field of
\&\s-1RFC5246\s0 et al. It is \fBnot\fR a \s-1NID.\s0
.PP
If the same custom extension type is received multiple times a fatal
\&\fBdecode_error\fR alert is sent and the handshake aborts. If a custom extension
is received in ServerHello which was not sent in ClientHello a fatal
\&\fBunsupported_extension\fR alert is sent and the handshake is aborted. The
ServerHello \fBadd_cb\fR callback is only called if the corresponding extension
was received in ClientHello. This is compliant with the \s-1TLS\s0 specifications.
This behaviour ensures that each callback is called at most once and that
an application can never send unsolicited extensions.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fISSL_CTX_add_client_custom_ext()\fR and \fISSL_CTX_add_server_custom_ext()\fR return 1 for
success and 0 for failure. A failure can occur if an attempt is made to
add the same \fBext_type\fR more than once, if an attempt is made to use an
extension type handled internally by OpenSSL or if an internal error occurs
(for example a memory allocation failure).
.PP
\&\fISSL_extension_supported()\fR returns 1 if the extension \fBext_type\fR is handled
internally by OpenSSL and 0 otherwise.
