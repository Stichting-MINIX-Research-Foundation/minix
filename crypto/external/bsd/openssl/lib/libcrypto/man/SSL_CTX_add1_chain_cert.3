.\"	$NetBSD: SSL_CTX_add1_chain_cert.3,v 1.1 2017/01/27 23:00:48 spz Exp $
.\"
.\" Automatically generated by Pod::Man 4.07 (Pod::Simple 3.32)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SSL_CTX_add1_chain_cert 3"
.TH SSL_CTX_add1_chain_cert 3 "2016-10-14" "1.0.2k" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
SSL_CTX_set0_chain, SSL_CTX_set1_chain, SSL_CTX_add0_chain_cert,
SSL_CTX_add1_chain_cert, SSL_CTX_get0_chain_certs, SSL_CTX_clear_chain_certs,
SSL_set0_chain, SSL_set1_chain, SSL_add0_chain_cert, SSL_add1_chain_cert,
SSL_get0_chain_certs, SSL_clear_chain_certs, SSL_CTX_build_cert_chain,
SSL_build_cert_chain, SSL_CTX_select_current_cert,
SSL_select_current_cert, SSL_CTX_set_current_cert, SSL_set_current_cert \- extra
chain certificate processing
.SH "LIBRARY"
libcrypto, -lcrypto
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/ssl.h>
\&
\& int SSL_CTX_set0_chain(SSL_CTX *ctx, STACK_OF(X509) *sk);
\& int SSL_CTX_set1_chain(SSL_CTX *ctx, STACK_OF(X509) *sk);
\& int SSL_CTX_add0_chain_cert(SSL_CTX *ctx, X509 *x509);
\& int SSL_CTX_add1_chain_cert(SSL_CTX *ctx, X509 *x509);
\& int SSL_CTX_get0_chain_certs(SSL_CTX *ctx, STACK_OF(X509) **sk);
\& int SSL_CTX_clear_chain_certs(SSL_CTX *ctx);
\&
\& int SSL_set0_chain(SSL *ssl, STACK_OF(X509) *sk);
\& int SSL_set1_chain(SSL *ssl, STACK_OF(X509) *sk);
\& int SSL_add0_chain_cert(SSL *ssl, X509 *x509);
\& int SSL_add1_chain_cert(SSL *ssl, X509 *x509);
\& int SSL_get0_chain_certs(SSL *ssl, STACK_OF(X509) **sk);
\& int SSL_clear_chain_certs(SSL *ssl);
\&
\& int SSL_CTX_build_cert_chain(SSL_CTX *ctx, flags);
\& int SSL_build_cert_chain(SSL *ssl, flags);
\&
\& int SSL_CTX_select_current_cert(SSL_CTX *ctx, X509 *x509);
\& int SSL_select_current_cert(SSL *ssl, X509 *x509);
\& int SSL_CTX_set_current_cert(SSL_CTX *ctx, long op);
\& int SSL_set_current_cert(SSL *ssl, long op);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fISSL_CTX_set0_chain()\fR and \fISSL_CTX_set1_chain()\fR set the certificate chain
associated with the current certificate of \fBctx\fR to \fBsk\fR.
.PP
\&\fISSL_CTX_add0_chain_cert()\fR and \fISSL_CTX_add1_chain_cert()\fR append the single
certificate \fBx509\fR to the chain associated with the current certificate of
\&\fBctx\fR.
.PP
\&\fISSL_CTX_get0_chain_certs()\fR retrieves the chain associated with the current
certificate of \fBctx\fR.
.PP
\&\fISSL_CTX_clear_chain_certs()\fR clears any existing chain associated with the
current certificate of \fBctx\fR.  (This is implemented by calling
\&\fISSL_CTX_set0_chain()\fR with \fBsk\fR set to \fB\s-1NULL\s0\fR).
.PP
\&\fISSL_CTX_build_cert_chain()\fR builds the certificate chain for \fBctx\fR normally
this uses the chain store or the verify store if the chain store is not set.
If the function is successful the built chain will replace any existing chain.
The \fBflags\fR parameter can be set to \fB\s-1SSL_BUILD_CHAIN_FLAG_UNTRUSTED\s0\fR to use
existing chain certificates as untrusted CAs, \fB\s-1SSL_BUILD_CHAIN_FLAG_NO_ROOT\s0\fR
to omit the root \s-1CA\s0 from the built chain, \fB\s-1SSL_BUILD_CHAIN_FLAG_CHECK\s0\fR to
use all existing chain certificates only to build the chain (effectively
sanity checking and rearranging them if necessary), the flag
\&\fB\s-1SSL_BUILD_CHAIN_FLAG_IGNORE_ERROR\s0\fR ignores any errors during verification:
if flag \fB\s-1SSL_BUILD_CHAIN_FLAG_CLEAR_ERROR\s0\fR is also set verification errors
are cleared from the error queue.
.PP
Each of these functions operates on the \fIcurrent\fR end entity
(i.e. server or client) certificate. This is the last certificate loaded or
selected on the corresponding \fBctx\fR structure.
.PP
\&\fISSL_CTX_select_current_cert()\fR selects \fBx509\fR as the current end entity
certificate, but only if \fBx509\fR has already been loaded into \fBctx\fR using a
function such as \fISSL_CTX_use_certificate()\fR.
.PP
\&\fISSL_set0_chain()\fR, \fISSL_set1_chain()\fR, \fISSL_add0_chain_cert()\fR,
\&\fISSL_add1_chain_cert()\fR, \fISSL_get0_chain_certs()\fR, \fISSL_clear_chain_certs()\fR,
\&\fISSL_build_cert_chain()\fR, \fISSL_select_current_cert()\fR and \fISSL_set_current_cert()\fR
are similar except they apply to \s-1SSL\s0 structure \fBssl\fR.
.PP
\&\fISSL_CTX_set_current_cert()\fR changes the current certificate to a value based
on the \fBop\fR argument. Currently \fBop\fR can be \fB\s-1SSL_CERT_SET_FIRST\s0\fR to use
the first valid certificate or \fB\s-1SSL_CERT_SET_NEXT\s0\fR to set the next valid
certificate after the current certificate. These two operations can be
used to iterate over all certificates in an \fB\s-1SSL_CTX\s0\fR structure.
.PP
\&\fISSL_set_current_cert()\fR also supports the option \fB\s-1SSL_CERT_SET_SERVER\s0\fR.
If \fBssl\fR is a server and has sent a certificate to a connected client
this option sets that certificate to the current certificate and returns 1.
If the negotiated ciphersuite is anonymous (and thus no certificate will
be sent) 2 is returned and the current certificate is unchanged. If \fBssl\fR
is not a server or a certificate has not been sent 0 is returned and
the current certificate is unchanged.
.PP
All these functions are implemented as macros. Those containing a \fB1\fR
increment the reference count of the supplied certificate or chain so it must
be freed at some point after the operation. Those containing a \fB0\fR do
not increment reference counts and the supplied certificate or chain
\&\fB\s-1MUST NOT\s0\fR be freed after the operation.
.SH "NOTES"
.IX Header "NOTES"
The chains associate with an \s-1SSL_CTX\s0 structure are copied to any \s-1SSL\s0
structures when \fISSL_new()\fR is called. \s-1SSL\s0 structures will not be affected
by any chains subsequently changed in the parent \s-1SSL_CTX.\s0
.PP
One chain can be set for each key type supported by a server. So, for example,
an \s-1RSA\s0 and a \s-1DSA\s0 certificate can (and often will) have different chains.
.PP
The functions \fISSL_CTX_build_cert_chain()\fR and \fISSL_build_cert_chain()\fR can
be used to check application configuration and to ensure any necessary
subordinate CAs are sent in the correct order. Misconfigured applications
sending incorrect certificate chains often cause problems with peers.
.PP
For example an application can add any set of certificates using
\&\fISSL_CTX_use_certificate_chain_file()\fR then call \fISSL_CTX_build_cert_chain()\fR
with the option \fB\s-1SSL_BUILD_CHAIN_FLAG_CHECK\s0\fR to check and reorder them.
.PP
Applications can issue non fatal warnings when checking chains by setting
the flag \fB\s-1SSL_BUILD_CHAIN_FLAG_IGNORE_ERRORS\s0\fR and checking the return
value.
.PP
Calling \fISSL_CTX_build_cert_chain()\fR or \fISSL_build_cert_chain()\fR is more
efficient than the automatic chain building as it is only performed once.
Automatic chain building is performed on each new session.
.PP
If any certificates are added using these functions no certificates added
using \fISSL_CTX_add_extra_chain_cert()\fR will be used.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fISSL_set_current_cert()\fR with \fB\s-1SSL_CERT_SET_SERVER\s0\fR return 1 for success, 2 if
no server certificate is used because the ciphersuites is anonymous and 0
for failure.
.PP
\&\fISSL_CTX_build_cert_chain()\fR and \fISSL_build_cert_chain()\fR return 1 for success
and 0 for failure. If the flag \fB\s-1SSL_BUILD_CHAIN_FLAG_IGNORE_ERROR\s0\fR and
a verification error occurs then 2 is returned.
.PP
All other functions return 1 for success and 0 for failure.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fISSL_CTX_add_extra_chain_cert\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
These functions were first added to OpenSSL 1.0.2.
