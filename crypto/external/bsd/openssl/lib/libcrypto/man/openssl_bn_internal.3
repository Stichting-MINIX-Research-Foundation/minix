.\"	$NetBSD: openssl_bn_internal.3,v 1.14 2015/06/12 17:01:14 christos Exp $
.\"
.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "bn_internal 3"
.TH bn_internal 3 "2009-12-26" "1.0.1n" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
bn_mul_words, bn_mul_add_words, bn_sqr_words, bn_div_words,
bn_add_words, bn_sub_words, bn_mul_comba4, bn_mul_comba8,
bn_sqr_comba4, bn_sqr_comba8, bn_cmp_words, bn_mul_normal,
bn_mul_low_normal, bn_mul_recursive, bn_mul_part_recursive,
bn_mul_low_recursive, bn_mul_high, bn_sqr_normal, bn_sqr_recursive,
bn_expand, bn_wexpand, bn_expand2, bn_fix_top, bn_check_top,
bn_print, bn_dump, bn_set_max, bn_set_high, bn_set_low \- BIGNUM
library internal functions
.SH "LIBRARY"
libcrypto, -lcrypto
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/bn.h>
\&
\& BN_ULONG bn_mul_words(BN_ULONG *rp, BN_ULONG *ap, int num, BN_ULONG w);
\& BN_ULONG bn_mul_add_words(BN_ULONG *rp, BN_ULONG *ap, int num,
\&   BN_ULONG w);
\& void     bn_sqr_words(BN_ULONG *rp, BN_ULONG *ap, int num);
\& BN_ULONG bn_div_words(BN_ULONG h, BN_ULONG l, BN_ULONG d);
\& BN_ULONG bn_add_words(BN_ULONG *rp, BN_ULONG *ap, BN_ULONG *bp,
\&   int num);
\& BN_ULONG bn_sub_words(BN_ULONG *rp, BN_ULONG *ap, BN_ULONG *bp,
\&   int num);
\&
\& void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b);
\& void bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b);
\& void bn_sqr_comba4(BN_ULONG *r, BN_ULONG *a);
\& void bn_sqr_comba8(BN_ULONG *r, BN_ULONG *a);
\&
\& int bn_cmp_words(BN_ULONG *a, BN_ULONG *b, int n);
\&
\& void bn_mul_normal(BN_ULONG *r, BN_ULONG *a, int na, BN_ULONG *b,
\&   int nb);
\& void bn_mul_low_normal(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n);
\& void bn_mul_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n2,
\&   int dna,int dnb,BN_ULONG *tmp);
\& void bn_mul_part_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b,
\&   int n, int tna,int tnb, BN_ULONG *tmp);
\& void bn_mul_low_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b,
\&   int n2, BN_ULONG *tmp);
\& void bn_mul_high(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, BN_ULONG *l,
\&   int n2, BN_ULONG *tmp);
\&
\& void bn_sqr_normal(BN_ULONG *r, BN_ULONG *a, int n, BN_ULONG *tmp);
\& void bn_sqr_recursive(BN_ULONG *r, BN_ULONG *a, int n2, BN_ULONG *tmp);
\&
\& void mul(BN_ULONG r, BN_ULONG a, BN_ULONG w, BN_ULONG c);
\& void mul_add(BN_ULONG r, BN_ULONG a, BN_ULONG w, BN_ULONG c);
\& void sqr(BN_ULONG r0, BN_ULONG r1, BN_ULONG a);
\&
\& BIGNUM *bn_expand(BIGNUM *a, int bits);
\& BIGNUM *bn_wexpand(BIGNUM *a, int n);
\& BIGNUM *bn_expand2(BIGNUM *a, int n);
\& void bn_fix_top(BIGNUM *a);
\&
\& void bn_check_top(BIGNUM *a);
\& void bn_print(BIGNUM *a);
\& void bn_dump(BN_ULONG *d, int n);
\& void bn_set_max(BIGNUM *a);
\& void bn_set_high(BIGNUM *r, BIGNUM *a, int n);
\& void bn_set_low(BIGNUM *r, BIGNUM *a, int n);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This page documents the internal functions used by the OpenSSL
\&\fB\s-1BIGNUM\s0\fR implementation. They are described here to facilitate
debugging and extending the library. They are \fInot\fR to be used by
applications.
.SS "The \s-1BIGNUM\s0 structure"
.IX Subsection "The BIGNUM structure"
.Vb 1
\& typedef struct bignum_st BIGNUM;
\&
\& struct bignum_st
\&        {
\&        BN_ULONG *d;    /* Pointer to an array of \*(AqBN_BITS2\*(Aq bit chunks. */
\&        int top;        /* Index of last used d +1. */
\&        /* The next are internal book keeping for bn_expand. */
\&        int dmax;       /* Size of the d array. */
\&        int neg;        /* one if the number is negative */
\&        int flags;
\&        };
.Ve
.PP
The integer value is stored in \fBd\fR, a \fImalloc()\fRed array of words (\fB\s-1BN_ULONG\s0\fR),
least significant word first. A \fB\s-1BN_ULONG\s0\fR can be either 16, 32 or 64 bits
in size, depending on the 'number of bits' (\fB\s-1BITS2\s0\fR) specified in
\&\f(CW\*(C`openssl/bn.h\*(C'\fR.
.PP
\&\fBdmax\fR is the size of the \fBd\fR array that has been allocated.  \fBtop\fR
is the number of words being used, so for a value of 4, bn.d[0]=4 and
bn.top=1.  \fBneg\fR is 1 if the number is negative.  When a \fB\s-1BIGNUM\s0\fR is
\&\fB0\fR, the \fBd\fR field can be \fB\s-1NULL\s0\fR and \fBtop\fR == \fB0\fR.
.PP
\&\fBflags\fR is a bit field of flags which are defined in \f(CW\*(C`openssl/bn.h\*(C'\fR. The
flags begin with \fB\s-1BN_FLG_\s0\fR. The macros BN_set_flags(b,n) and
BN_get_flags(b,n) exist to enable or fetch flag(s) \fBn\fR from \fB\s-1BIGNUM\s0\fR
structure \fBb\fR.
.PP
Various routines in this library require the use of temporary
\&\fB\s-1BIGNUM\s0\fR variables during their execution.  Since dynamic memory
allocation to create \fB\s-1BIGNUM\s0\fRs is rather expensive when used in
conjunction with repeated subroutine calls, the \fB\s-1BN_CTX\s0\fR structure is
used.  This structure contains \fB\s-1BN_CTX_NUM\s0\fR \fB\s-1BIGNUM\s0\fRs, see
\&\fIBN_CTX_start\fR\|(3).
.SS "Low-level arithmetic operations"
.IX Subsection "Low-level arithmetic operations"
These functions are implemented in C and for several platforms in
assembly language:
.PP
bn_mul_words(\fBrp\fR, \fBap\fR, \fBnum\fR, \fBw\fR) operates on the \fBnum\fR word
arrays \fBrp\fR and \fBap\fR.  It computes \fBap\fR * \fBw\fR, places the result
in \fBrp\fR, and returns the high word (carry).
.PP
bn_mul_add_words(\fBrp\fR, \fBap\fR, \fBnum\fR, \fBw\fR) operates on the \fBnum\fR
word arrays \fBrp\fR and \fBap\fR.  It computes \fBap\fR * \fBw\fR + \fBrp\fR, places
the result in \fBrp\fR, and returns the high word (carry).
.PP
bn_sqr_words(\fBrp\fR, \fBap\fR, \fBn\fR) operates on the \fBnum\fR word array
\&\fBap\fR and the 2*\fBnum\fR word array \fBap\fR.  It computes \fBap\fR * \fBap\fR
word-wise, and places the low and high bytes of the result in \fBrp\fR.
.PP
bn_div_words(\fBh\fR, \fBl\fR, \fBd\fR) divides the two word number (\fBh\fR,\fBl\fR)
by \fBd\fR and returns the result.
.PP
bn_add_words(\fBrp\fR, \fBap\fR, \fBbp\fR, \fBnum\fR) operates on the \fBnum\fR word
arrays \fBap\fR, \fBbp\fR and \fBrp\fR.  It computes \fBap\fR + \fBbp\fR, places the
result in \fBrp\fR, and returns the high word (carry).
.PP
bn_sub_words(\fBrp\fR, \fBap\fR, \fBbp\fR, \fBnum\fR) operates on the \fBnum\fR word
arrays \fBap\fR, \fBbp\fR and \fBrp\fR.  It computes \fBap\fR \- \fBbp\fR, places the
result in \fBrp\fR, and returns the carry (1 if \fBbp\fR > \fBap\fR, 0
otherwise).
.PP
bn_mul_comba4(\fBr\fR, \fBa\fR, \fBb\fR) operates on the 4 word arrays \fBa\fR and
\&\fBb\fR and the 8 word array \fBr\fR.  It computes \fBa\fR*\fBb\fR and places the
result in \fBr\fR.
.PP
bn_mul_comba8(\fBr\fR, \fBa\fR, \fBb\fR) operates on the 8 word arrays \fBa\fR and
\&\fBb\fR and the 16 word array \fBr\fR.  It computes \fBa\fR*\fBb\fR and places the
result in \fBr\fR.
.PP
bn_sqr_comba4(\fBr\fR, \fBa\fR, \fBb\fR) operates on the 4 word arrays \fBa\fR and
\&\fBb\fR and the 8 word array \fBr\fR.
.PP
bn_sqr_comba8(\fBr\fR, \fBa\fR, \fBb\fR) operates on the 8 word arrays \fBa\fR and
\&\fBb\fR and the 16 word array \fBr\fR.
.PP
The following functions are implemented in C:
.PP
bn_cmp_words(\fBa\fR, \fBb\fR, \fBn\fR) operates on the \fBn\fR word arrays \fBa\fR
and \fBb\fR.  It returns 1, 0 and \-1 if \fBa\fR is greater than, equal and
less than \fBb\fR.
.PP
bn_mul_normal(\fBr\fR, \fBa\fR, \fBna\fR, \fBb\fR, \fBnb\fR) operates on the \fBna\fR
word array \fBa\fR, the \fBnb\fR word array \fBb\fR and the \fBna\fR+\fBnb\fR word
array \fBr\fR.  It computes \fBa\fR*\fBb\fR and places the result in \fBr\fR.
.PP
bn_mul_low_normal(\fBr\fR, \fBa\fR, \fBb\fR, \fBn\fR) operates on the \fBn\fR word
arrays \fBr\fR, \fBa\fR and \fBb\fR.  It computes the \fBn\fR low words of
\&\fBa\fR*\fBb\fR and places the result in \fBr\fR.
.PP
bn_mul_recursive(\fBr\fR, \fBa\fR, \fBb\fR, \fBn2\fR, \fBdna\fR, \fBdnb\fR, \fBt\fR) operates
on the word arrays \fBa\fR and \fBb\fR of length \fBn2\fR+\fBdna\fR and \fBn2\fR+\fBdnb\fR
(\fBdna\fR and \fBdnb\fR are currently allowed to be 0 or negative) and the 2*\fBn2\fR
word arrays \fBr\fR and \fBt\fR.  \fBn2\fR must be a power of 2.  It computes
\&\fBa\fR*\fBb\fR and places the result in \fBr\fR.
.PP
bn_mul_part_recursive(\fBr\fR, \fBa\fR, \fBb\fR, \fBn\fR, \fBtna\fR, \fBtnb\fR, \fBtmp\fR)
operates on the word arrays \fBa\fR and \fBb\fR of length \fBn\fR+\fBtna\fR and
\&\fBn\fR+\fBtnb\fR and the 4*\fBn\fR word arrays \fBr\fR and \fBtmp\fR.
.PP
bn_mul_low_recursive(\fBr\fR, \fBa\fR, \fBb\fR, \fBn2\fR, \fBtmp\fR) operates on the
\&\fBn2\fR word arrays \fBr\fR and \fBtmp\fR and the \fBn2\fR/2 word arrays \fBa\fR
and \fBb\fR.
.PP
bn_mul_high(\fBr\fR, \fBa\fR, \fBb\fR, \fBl\fR, \fBn2\fR, \fBtmp\fR) operates on the
\&\fBn2\fR word arrays \fBr\fR, \fBa\fR, \fBb\fR and \fBl\fR (?) and the 3*\fBn2\fR word
array \fBtmp\fR.
.PP
\&\fIBN_mul()\fR calls \fIbn_mul_normal()\fR, or an optimized implementation if the
factors have the same size: \fIbn_mul_comba8()\fR is used if they are 8
words long, \fIbn_mul_recursive()\fR if they are larger than
\&\fB\s-1BN_MULL_SIZE_NORMAL\s0\fR and the size is an exact multiple of the word
size, and \fIbn_mul_part_recursive()\fR for others that are larger than
\&\fB\s-1BN_MULL_SIZE_NORMAL\s0\fR.
.PP
bn_sqr_normal(\fBr\fR, \fBa\fR, \fBn\fR, \fBtmp\fR) operates on the \fBn\fR word array
\&\fBa\fR and the 2*\fBn\fR word arrays \fBtmp\fR and \fBr\fR.
.PP
The implementations use the following macros which, depending on the
architecture, may use \*(L"long long\*(R" C operations or inline assembler.
They are defined in \f(CW\*(C`bn_lcl.h\*(C'\fR.
.PP
mul(\fBr\fR, \fBa\fR, \fBw\fR, \fBc\fR) computes \fBw\fR*\fBa\fR+\fBc\fR and places the
low word of the result in \fBr\fR and the high word in \fBc\fR.
.PP
mul_add(\fBr\fR, \fBa\fR, \fBw\fR, \fBc\fR) computes \fBw\fR*\fBa\fR+\fBr\fR+\fBc\fR and
places the low word of the result in \fBr\fR and the high word in \fBc\fR.
.PP
sqr(\fBr0\fR, \fBr1\fR, \fBa\fR) computes \fBa\fR*\fBa\fR and places the low word
of the result in \fBr0\fR and the high word in \fBr1\fR.
.SS "Size changes"
.IX Subsection "Size changes"
\&\fIbn_expand()\fR ensures that \fBb\fR has enough space for a \fBbits\fR bit
number.  \fIbn_wexpand()\fR ensures that \fBb\fR has enough space for an
\&\fBn\fR word number.  If the number has to be expanded, both macros
call \fIbn_expand2()\fR, which allocates a new \fBd\fR array and copies the
data.  They return \fB\s-1NULL\s0\fR on error, \fBb\fR otherwise.
.PP
The \fIbn_fix_top()\fR macro reduces \fBa\->top\fR to point to the most
significant non-zero word plus one when \fBa\fR has shrunk.
.SS "Debugging"
.IX Subsection "Debugging"
\&\fIbn_check_top()\fR verifies that \f(CW\*(C`((a)\->top >= 0 && (a)\->top
<= (a)\->dmax)\*(C'\fR.  A violation will cause the program to abort.
.PP
\&\fIbn_print()\fR prints \fBa\fR to stderr. \fIbn_dump()\fR prints \fBn\fR words at \fBd\fR
(in reverse order, i.e. most significant word first) to stderr.
.PP
\&\fIbn_set_max()\fR makes \fBa\fR a static number with a \fBdmax\fR of its current size.
This is used by \fIbn_set_low()\fR and \fIbn_set_high()\fR to make \fBr\fR a read-only
\&\fB\s-1BIGNUM\s0\fR that contains the \fBn\fR low or high words of \fBa\fR.
.PP
If \fB\s-1BN_DEBUG\s0\fR is not defined, \fIbn_check_top()\fR, \fIbn_print()\fR, \fIbn_dump()\fR
and \fIbn_set_max()\fR are defined as empty macros.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIopenssl_bn\fR\|(3)
