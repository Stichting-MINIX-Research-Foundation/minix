#	$NetBSD: Makefile,v 1.157 2012/09/20 15:50:20 pooka Exp $

.include <bsd.own.mk>

.if defined(HAVE_GCC) || defined(HAVE_PCC)
TOOLCHAIN_BITS= gmake .WAIT
.endif

.if ${TOOLCHAIN_MISSING} == "no"
.if defined(HAVE_GCC)
.if ${HAVE_GCC} >= 45
TOOLCHAIN_BITS+= gmp .WAIT
TOOLCHAIN_BITS+= mpfr .WAIT
TOOLCHAIN_BITS+= mpc .WAIT
.endif
.endif
.endif

.if ${TOOLCHAIN_MISSING} == "no"
TOOLCHAIN_BITS+= binutils .WAIT
.endif

.if defined(HAVE_GCC)
.if ${TOOLCHAIN_MISSING} == "no"
TOOLCHAIN_BITS+= gcc
.  if ${MKCROSSGDB:Uno} != "no"
TOOLCHAIN_BITS+= gdb
.  endif
TOOLCHAIN_BITS+= .WAIT
.endif
.endif

.if defined(HAVE_PCC)
.if ${TOOLCHAIN_MISSING} == "no"
TOOLCHAIN_BITS+= pcc
.endif
.endif

.if !defined(__MINIX)
.if ${TOOLCHAIN_MISSING} == "no"
# XXX Eventually, we want to be able to build dbsym and mdsetimage
# XXX if EXTERNAL_TOOLCHAIN is set.
TOOLCHAIN_BITS+= dbsym mdsetimage
.endif
.endif # !defined(__MINIX)

DTRACE_BITS=
.if ${MKDTRACE} != "no"
DTRACE_BITS+= .WAIT libelf
DTRACE_BITS+= .WAIT libdwarf
DTRACE_BITS+= .WAIT libctf 
DTRACE_BITS+= .WAIT ctfconvert ctfmerge
.endif

LINT_BITS=
.if ${MKLINT} != "no"
LINT_BITS= lint lint2
.endif

# Dependencies in SUBDIR below ordered to maximize parallel ability.
SUBDIR=	host-mkdep .WAIT compat .WAIT \
	binstall .WAIT mktemp .WAIT sed .WAIT \
		genassym join \
		lorder makewhatis mkdep mtree nbperf .WAIT tsort \
		m4 \
	.WAIT texinfo \
	.WAIT mkfs.mfs \
	.WAIT toproto \
	.WAIT yacc \
	.WAIT awk \
	.WAIT tic \
	.WAIT lex \
	.WAIT pax \
	.WAIT ${TOOLCHAIN_BITS} \
	${DTRACE_BITS} \
		 cat cksum \
		file \
		.WAIT \
		pwd_mkdb stat zic

.if ${MKLLVM} != "no"
# .WAIT between llvm-tblgen and llvm-clang-tblgen ensures install
# rules works correctly
SUBDIR+= \
	llvm .WAIT \
	llvm-lib/libLLVMSupport llvm-lib/libLLVMTableGen .WAIT \
	llvm-tblgen .WAIT llvm-clang-tblgen .WAIT \
	llvm-include .WAIT \
	llvm-lib .WAIT \
	llvm-clang
.endif

.if ${MKMAN} != "no" || ${MKDOC} != "no" || ${MKHTML} != "no"
.  if ${MKGROFF} != "no"
SUBDIR+=	groff
.  endif
SUBDIR+=	mandoc
.endif

.if ${MKMAINTAINERTOOLS:Uno} != "no"
SUBDIR+=	autoconf .WAIT gettext
.endif

.if ${USE_PIGZGZIP} != "no"
SUBDIR+=	pigz
.endif

.if ${MACHINE} == "hp700"
SUBDIR+=	hp700-mkboot
.endif

.if ${MACHINE} == "ibmnws"
SUBDIR+=	ibmnws-ncdcs
.endif

.if ${MACHINE} == "macppc"
SUBDIR+=	macppc-fixcoff
.endif

.if (${MACHINE} == "prep" || ${MACHINE} == "rs6000" || ${MACHINE} == "bebox")
SUBDIR+=	powerpc-mkbootimage
.endif

.if ${MACHINE_ARCH} == "m68k"
SUBDIR+=	m68k-elf2aout
.endif

.if (${MACHINE_ARCH} == "mipsel" || ${MACHINE_ARCH} == "mipseb" || \
     ${MACHINE_ARCH} == "mips64el" || ${MACHINE_ARCH} == "mips64eb")
SUBDIR+=	mips-elf2ecoff
.endif

.if (${MACHINE} == "sgimips")
SUBDIR+=	sgivol
.endif

.if ${MACHINE} == "acorn32"
SUBDIR+=	sparkcrc
.endif

.if (${MACHINE_ARCH} == "sparc" || ${MACHINE_ARCH} == "sparc64")
SUBDIR+=	fgen
.endif

.if ${MACHINE} == "amiga"
SUBDIR+=	amiga-elf2bb
SUBDIR+=	amiga-txlt
.endif

.if ${MACHINE} == "hp300"
SUBDIR+=	hp300-mkboot
.endif

.if !defined(__MINIX)
.if ${MACHINE} == "evbarm" || ${MACHINE} == "evbmips" || \
    ${MACHINE} == "evbppc" || ${MACHINE} == "sandpoint"
SUBDIR+=	mkubootimage
.endif
.endif # !defined(__MINIX)

check_MKTOOLS: .PHONY .NOTMAIN
.if ${MKTOOLS:Uyes} == "no"
	@echo '*** WARNING: "MKTOOLS" is set to "no"; this will prevent building and'
	@echo '*** updating your host toolchain.  This should be used only as a'
	@echo '*** temporary workaround for toolchain problems, as it will result'
	@echo '*** in version skew and build errors over time!'
.endif

.if ${MKTOOLS:Uyes} == "no" || ${USETOOLS} != "yes"	# {
realall realdepend install: check_MKTOOLS

.for dir in ${SUBDIR:N.WAIT}
all-${dir} depend-${dir} dependall-${dir} install-${dir}:
	@true
.endfor
.endif							# }

.include <bsd.subdir.mk>
.include <bsd.obj.mk>

.if !defined(PREVIOUSTOOLDIR)
.  if exists(PREVIOUSTOOLDIR)
PREVIOUSTOOLDIR!=	cat PREVIOUSTOOLDIR
.  else
PREVIOUSTOOLDIR=	
.  endif
.endif

CLEANFILES+=	PREVIOUSTOOLDIR

realall realdepend: .MAKE
.if !empty(PREVIOUSTOOLDIR) && "${PREVIOUSTOOLDIR}" != "${TOOLDIR}"
	@echo "*** WARNING: TOOLDIR has moved?"
	@echo "*** PREVIOUSTOOLDIR '${PREVIOUSTOOLDIR}'"
	@echo "***     !=  TOOLDIR '${TOOLDIR}'"
	@echo "*** Cleaning mis-matched tools"
	rm -f PREVIOUSTOOLDIR
	(cd ${.CURDIR} && ${MAKE} PREVIOUSTOOLDIR=${TOOLDIR} cleandir)
.endif
	echo ${TOOLDIR} >PREVIOUSTOOLDIR

# For each .WAIT point, make sure the immediately preceding target is
# installed before building anything after that point.
# (dsl: which means that with: 'a b .WAIT c' the build of 'c' waits for the
# install of 'b', but not the install of 'a'.)
#
# We use the "internal" targets and dependencies generated by <bsd.subdir.mk>
# to achieve this. These targets look like:
#	subdir-all:	all-dir1     [.WAIT] all-dir2     etc..
#	subdir-install:	install-dir1 [.WAIT] install-dir2 etc..
# and so on for each element in ${TARGETS}, with .WAIT sources inserted at
# places corresponding to the .WAITs in our $SUBDIR variable.
#
# Also, since we're now mixing `install' with `all' and `depend' targets
# an order relationship between those in each individual subdirectory
# must be established.
#
_deps:=
_prev:=

.for d in ${SUBDIR}				# {
_this:=		${d}

.if ${_this} == ".WAIT"				# {

# setup dependency to apply to all/depend targets in the next group
_deps:=		${_deps} ${_prev:S/^/install-/}

# if we're building *only* individual targets (i.e. "dependall-yacc"),
# make sure prerequisite tools build before installing
# XXX: dsl: this is likely to generate a dependency loop since there is
# a .ORDER releation between the nodes as well.
.if !make(all) && !make(dependall) && !make(install)
install-${_prev}: dependall-${_prev}
.endif

.else # ${_this} != ".WAIT"			# } {

# order depend/all/install targets for ${d} subdir.
.ORDER: depend-${d} all-${d} dependall-${d} install-${d}

# prevent cleandir in real{all,depend} from interfering with subdir makes
.ORDER: realdepend dependall-${d}
.ORDER: realdepend depend-${d}
.ORDER: realall all-${d}

# make all/depend-${d} dependent on list of install targets
depend-${d} all-${d} dependall-${d}: ${_deps}

.endif # ${_this} != ".WAIT"			# }

# stash current name in case the next entry is .WAIT
_prev:=		${d}
.endfor						# }

cleandir:
	rm -f ${CLEANFILES}
